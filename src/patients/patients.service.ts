import { Injectable, NotFoundException, BadRequestException } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { Patient, Species, Gender } from './entities/patient.entity';

export interface CreatePatientDto {
  name: string;
  species: Species;
  breed: string;
  gender: Gender;
  birthDate: Date;
  ownerId: string;
  tags?: string[];
}

export interface UpdatePatientDto {
  name?: string;
  species?: Species;
  breed?: string;
  gender?: Gender;
  birthDate?: Date;
  tags?: string[];
}

export interface PaginationParams {
  page: number;
  limit: number;
  species?: Species;
  search?: string;
}

export interface PaginatedResponse<T> {
  data: T[];
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}

@Injectable()
export class PatientsService {
  constructor(private prisma: PrismaService) {}

  async create(createPatientDto: CreatePatientDto): Promise<Patient> {
    try {
      // Validate the data by creating a Patient entity first
      const patientData = {
        id: '', // Will be generated by database
        ...createPatientDto,
        tags: createPatientDto.tags || [],
        isActive: true,
        createdAt: new Date(),
      };
      
      // This will throw an error if validation fails
      new Patient(patientData);

      const data = {
        name: createPatientDto.name,
        species: createPatientDto.species,
        breed: createPatientDto.breed,
        gender: createPatientDto.gender,
        birthDate: createPatientDto.birthDate,
        ownerId: createPatientDto.ownerId,
        tags: JSON.stringify(createPatientDto.tags || []),
      };

      const createdPatient = await this.prisma.patient.create({ data });
      return this.mapToPatientEntity(createdPatient);
    } catch (error) {
      if (error.message.includes('Name cannot be empty') ||
          error.message.includes('Invalid species') ||
          error.message.includes('Invalid gender') ||
          error.message.includes('Birth date cannot be in the future') ||
          error.message.includes('Owner ID cannot be empty')) {
        throw new BadRequestException(error.message);
      }
      throw error;
    }
  }

  async findAll(params: PaginationParams): Promise<PaginatedResponse<Patient>> {
    const { page = 1, limit = 10, species, search } = params;
    const skip = (page - 1) * limit;

    const where: any = { isActive: true };
    
    if (species) {
      where.species = species;
    }
    
    if (search) {
      where.name = { contains: search, mode: 'insensitive' };
    }

    const [patients, total] = await Promise.all([
      this.prisma.patient.findMany({
        skip,
        take: limit,
        where,
        orderBy: { createdAt: 'desc' },
      }),
      this.prisma.patient.count({ where }),
    ]);

    const data = patients.map(patient => this.mapToPatientEntity(patient));
    const totalPages = Math.ceil(total / limit);

    return {
      data,
      total,
      page,
      limit,
      totalPages,
    };
  }

  async findOne(id: string): Promise<Patient> {
    const patient = await this.prisma.patient.findUnique({
      where: { id },
    });

    if (!patient) {
      throw new NotFoundException(`Patient with ID ${id} not found`);
    }

    return this.mapToPatientEntity(patient);
  }

  async update(id: string, updatePatientDto: UpdatePatientDto): Promise<Patient> {
    const existingPatient = await this.prisma.patient.findUnique({
      where: { id },
    });

    if (!existingPatient) {
      throw new NotFoundException(`Patient with ID ${id} not found`);
    }

    const updateData: any = { ...updatePatientDto };
    
    if (updatePatientDto.tags) {
      updateData.tags = JSON.stringify(updatePatientDto.tags);
    }

    const updatedPatient = await this.prisma.patient.update({
      where: { id },
      data: updateData,
    });

    return this.mapToPatientEntity(updatedPatient);
  }

  async remove(id: string): Promise<Patient> {
    const existingPatient = await this.prisma.patient.findUnique({
      where: { id },
    });

    if (!existingPatient) {
      throw new NotFoundException(`Patient with ID ${id} not found`);
    }

    const updatedPatient = await this.prisma.patient.update({
      where: { id },
      data: { isActive: false },
    });

    return this.mapToPatientEntity(updatedPatient);
  }

  async findByOwnerId(ownerId: string): Promise<Patient[]> {
    const patients = await this.prisma.patient.findMany({
      where: { ownerId, isActive: true },
      orderBy: { createdAt: 'desc' },
    });

    return patients.map(patient => this.mapToPatientEntity(patient));
  }

  async addTag(id: string, tag: string): Promise<Patient> {
    const existingPatient = await this.prisma.patient.findUnique({
      where: { id },
    });

    if (!existingPatient) {
      throw new NotFoundException(`Patient with ID ${id} not found`);
    }

    const currentTags = JSON.parse(existingPatient.tags || '[]');
    if (!currentTags.includes(tag)) {
      currentTags.push(tag);
    }

    const updatedPatient = await this.prisma.patient.update({
      where: { id },
      data: { tags: JSON.stringify(currentTags) },
    });

    return this.mapToPatientEntity(updatedPatient);
  }

  async removeTag(id: string, tag: string): Promise<Patient> {
    const existingPatient = await this.prisma.patient.findUnique({
      where: { id },
    });

    if (!existingPatient) {
      throw new NotFoundException(`Patient with ID ${id} not found`);
    }

    const currentTags = JSON.parse(existingPatient.tags || '[]');
    const filteredTags = currentTags.filter((t: string) => t !== tag);

    const updatedPatient = await this.prisma.patient.update({
      where: { id },
      data: { tags: JSON.stringify(filteredTags) },
    });

    return this.mapToPatientEntity(updatedPatient);
  }

  private mapToPatientEntity(prismaPatient: any): Patient {
    return new Patient({
      id: prismaPatient.id,
      name: prismaPatient.name,
      species: prismaPatient.species as Species,
      breed: prismaPatient.breed,
      gender: prismaPatient.gender as Gender,
      birthDate: prismaPatient.birthDate,
      ownerId: prismaPatient.ownerId,
      tags: JSON.parse(prismaPatient.tags || '[]'),
      isActive: prismaPatient.isActive,
      createdAt: prismaPatient.createdAt,
      updatedAt: prismaPatient.updatedAt,
    });
  }
}